---
title: "Asymmetric Multidimensional Scaling"
date: "`r Sys.Date()`"
output: 
  html_vignette: 
    toc: yes
    self_contained: yes
---
<!--
  %\VignetteIndexEntry{Scaling asymmetry}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
-->
## Asymmetry

To summarize this paper, the authors main conclusions were
1. In many models, such as the slide-vector model and the mds model with unicities skew-symmetry is modelled by a linear model, and other models such as the Gower diagram and the asymscal model use a bilinear model
2. a drawback of the linear model is that is a transitive model, and that it does not model circular triads in the data.


## Asymscal
The ASYMSCAL model is a weighted Euclidean model proposed by Young. Asymmetric distances are obtained by applying weights to each row of the configuration matrix. These weights stretch or shrink the dimensions of the model, and if they are varying asymmetry is predicted by the model. If the weights are all equal, the distances are symmetric resulting in the standard Euclidean distance model.

The optimization problem finds an  $n\times p$ matrix $X$, and an $n\times p$ matrix \(V\) such that \(d_{ij}(X)\approx q_{ij}\), where
\begin{equation}
\label{eq:dist}
d_{ij}(X)=\sqrt{\sum_{s=1}^pv_{is}(x_{is}-x_{js})^2}.
\end{equation}
The index $s=1,\ldots,p$ denotes the number of dimensions in the Euclidean 
space. The elements of $X$ are called \emph{configurations} of the objects, and the elements of $V$ are called \emph{weights}. The weights $v_{is}$ in this equation models the asymmetry. The direction of the comparison is important in this analysis, when  $i$ is compared to $j$ weight $v_{is}$ is applied to dimension $s$, whereas weight $v_{js}$ is applied to dimension $s$ when $j$ is compared to $i$ resulting in an asymmetric relation between $i$ and $j$. The distance between $i$ and $j$ is symmetric if the weights are equal.

Figure 1 shows a group space, and two individual spaces. Two points are coloured, one red, and one blue. The red object has weight vector (.25,1), and the individual space of this object is shown in the middle panel. In the right panel the individual space of the blue object with weight vector (1,.25) is shown. These two objects have similar values on the second dimension and different values on the first dimension. If we apply weights to these two dimensions for these objects the weights for the second dimension do not matter very much because these objects have similar coordinates on this dimension. The distance from object one to object two is calculated with the weights of object one applied to the dimensions. The first dimension is less important for this object resulting in a small distance between this object and object two. For object two, the second dimension is less important resulting in a larger distance between object one and object two. Thus, the distance from object one to object two is smaller than the distance from object two to object one.
```{r asymscal, echo=FALSE, fig.width = 10, fig.height = 8}
library(asymmetry)
# m <- matrix(c(3,1,2,2,4,2.2,1.5,3.3,2.2,5.5,3,4), 6, 2, byrow=TRUE)
# plot(m)
# sk <- m%*%t(matrix(c(m[,2],-1*m[,1]),6,2))
# e<-matrix(1,6,1)
# sk - e%*%t(colSums(sk)) - as.matrix(rowSums(sk))%*%t(e)

x<-matrix(c(-2,-1,0,1,2, -2,-1,0,1,1.75, 2.5,1,0,1.2,2.3, -2,1,0,-1,2),nrow=10,ncol=2)
par(mfrow = c(1,3),pty="s")
plot(x, xlim =c(-2.5,2.5),ylim =c(-2.5,2.5),xlab='Dimension 1',ylab='Dimension 2', main = "Group Space")
points(x=-2,y=2.5,col = "red", pch = 19)
points(x=2,y=2.3,col = "blue", pch = 19)

plot(x%*%diag(c(.25,1)), xlim =c(-2.5,2.5),ylim =c(-2.5,2.5),xlab='Dimension 1',ylab='Dimension 2',main="Object 1 (.25,1)")
points(x=-2*.25,y=2.5,col = "red", pch = 19)
points(x=2*.25,y=2.3,col = "blue", pch = 19)

plot(x%*%diag(c(1,.25)), xlim =c(-2.5,2.5),ylim =c(-2.5,2.5),xlab='Dimension 1',ylab='Dimension 2', main = "Object 2 (1,.25)")
points(x=-2,y=2.5*.25,col = "red", pch = 19)
points(x=2,y=2.3*.25,col = "blue", pch = 19)


```

## Slide-vector model
The slide vector model is a multidimensional scaling (MDS) model for asymmetric data. MDS fits symmetric distances to data, whereas this model fits modified distances which are asymmetric. A distance model is fitted to the symmetric part of the data whereas the asymmetric part of the data is represented by projections of the coordinates onto the slide-vector. The slide-vector points in the direction of large asymmetries in the data. The distance is modified in such a way that the distance between two points that are parallel  to the slide-vector is larger in the direction of this vector. The distance is smaller in the opposite direction. If the line connecting two points is perpendicular to the slide-vector the difference between the two projections is zero. In this case the distance between the two points is symmetric. The algorithm for fitting this model is derived from the majorization approach to multidimensional scaling.

The slide-vector model is given by the following equation
$$ d_{ij}(X;z)=\sqrt{\sum_{s=1}^p(x_{is}-x_{js}+z_{is})^2}.$$

The squared distances can be decomposed in a linear skew-symmetric and symmetric part.
$$ d_{ij}^2(X;z)=\sum_{s=1}^p (x_{is}-x_{js})^2+\sum_{s=1}^p z_{is}^2 + 2\sum_{s=1}^p( x_{is}-x_{js})z_{is}.$$

```{r slide-explain, echo=FALSE, fig.width = 10, fig.height = 8 }
par(pty="s",mfrow=c(1,2))
rows <- 6
m <- matrix(c(2,0,-1.5,3,4,5,4,3,-1,-2,4,-1.5),nrow=6,2)
plot(m, xlab = "dimension 1", ylab = "dimension 2", xlim = c(-2,7), ylim = c(-2,7))
slope <- -.45
intercept <- 0
negslope <- -1/slope
abline(intercept,slope, col ="pink",lty=2)
arrows(0,0,2,intercept+slope*2,col ="red")
#abline(4-negslope*2,negslope)
neginter <- m[6,2]-negslope*m[6,1]
#abline(m[6,2]-negslope*m[6,1],negslope)
s1 <- (intercept-neginter)/(negslope-slope)
s2 <- intercept + s1*slope
segments(s1,s2,m[6,1],m[6,2])
#segments(4,3,2,4)
for (i in 1:rows)
{
neginter <- m[i,2]-negslope*m[i,1]
s1 <- (intercept-neginter)/(negslope-slope)
s2 <- intercept + s1*slope
segments(s1,s2,m[i,1],m[i,2],col = "blue")
	
}
labels <- c("A","B","C","D","E","F")
for (i in 1:rows)
{

text(-.15+m[i,1],.3+m[i,2],labels[i])
}
#
# second application
#
plot(m, xlab = "dimension 1", ylab = "dimension 2", xlim = c(-2,7), ylim = c(-2,7))
slope <- .75
intercept <- 0
negslope <- -1/slope
abline(intercept,slope, col ="pink",lty=2)
arrows(0,0,2,intercept+slope*2,col ="red")
#abline(4-negslope*2,negslope)
neginter <- m[6,2]-negslope*m[6,1]
#abline(m[6,2]-negslope*m[6,1],negslope)
s1 <- (intercept-neginter)/(negslope-slope)
s2 <- intercept + s1*slope
segments(s1,s2,m[6,1],m[6,2])
#segments(4,3,2,4)
for (i in 1:rows)
{
neginter <- m[i,2]-negslope*m[i,1]
s1 <- (intercept-neginter)/(negslope-slope)
s2 <- intercept + s1*slope
segments(s1,s2,m[i,1],m[i,2],col = "blue")
	
}
labels <- c("A","B","C","D","E","F")
for (i in 1:rows)
{

text(.05+m[i,1],.3+m[i,2],labels[i])
}
```


The following lines of code generate a two-dimension representation of the English towns data for the slide-vector model.
```{r englishtowns, fig.width = 8, fig.height = 8 }
data(Englishtowns)
v<-slidevector(Englishtowns, ndim = 2, itmax = 250, eps = .001)
plot(v,col="blue",ylim=c(-150,300),xlim=c(-150,300))
```


